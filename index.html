<!doctype html>
<!-- Italian Number Trainer PWA -->
<!DOCTYPE html>
<html lang="it">
<head>
  <!-- PWA additions -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f172a">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta charset="UTF-8">
  <title>Italian Number Trainer + Stats (Weak Numbers)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#121212;
      --fg:#ffffff;
      --accent:#4bc0c0;
      --muted:#888;
      --good:#8fd18f;
      --bad:#ff8c8c;
    }
    *{box-sizing:border-box}
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Nunito', sans-serif;
      background-color: var(--bg);
      color: var(--fg);
      text-align: center;
      padding: 2rem 1rem 4rem;
      margin:0;
    }
    h1{margin:0 0 0.75rem 0;font-size:1.6rem; font-weight:700}
    #number, #translation, #timer {
      font-size: clamp(1.4rem, 2.5vw + 1rem, 2.2rem);
      margin: 0.6rem 0;
      letter-spacing: 0.5px;
    }
    #metaRow{
      display:flex; gap:0.75rem; justify-content:center; flex-wrap:wrap; align-items:center;
      margin: 0.5rem 0 1rem;
    }
    .pill{
      border:1px solid var(--accent); color:var(--accent);
      padding:0.25rem 0.6rem; border-radius:999px; font-size:0.95rem
    }
    input {
      font-size: 1.2rem;
      padding: 0.3rem 0.5rem;
      text-align: center;
      border:1px solid #333; border-radius:6px; background:#1b1b1b; color:var(--fg);
    }
    button {
      font-size: 0.95rem;
      padding: 0.5rem 0.9rem;
      margin: 0.25rem;
      border: 2px solid var(--accent);
      border-radius: 10px;
      background-color: #1e1e1e;
      color: white;
      cursor:pointer;
      transition: transform .04s ease;
    }
    button:active{ transform: translateY(1px) }
    button.active {
      background-color: var(--accent);
      color: black;
    }
    select {
      background:#1b1b1b; color:#eee; border:1px solid #2a2a2a; border-radius:8px; padding:0.35rem 0.5rem;
    }
    #statsWrap{
      max-width: 1000px; margin: 1.25rem auto 0; text-align:left;
      padding:0 0.25rem;
    }
    .stats-grid{
      display:grid; grid-template-columns: 1fr; gap:0.75rem;
    }
    @media (min-width: 900px){
      .stats-grid{ grid-template-columns: 1.2fr 1fr; }
    }
    .card{
      background:#1a1a1a; border:1px solid #2a2a2a; border-radius:16px;
      padding:0.75rem 0.75rem 0.9rem;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2{
      margin:0 0 0.25rem; font-size:1.05rem; font-weight:700; color:#ddd
    }
    .subtle{color:#bbb; font-size:0.9rem; margin:0.1rem 0 0.5rem}
    canvas{ width:100%; height:180px; display:block; background:#111; border-radius:12px; }
    #spark{ height:90px }
    #legend{ display:flex; gap:1rem; align-items:center; flex-wrap:wrap; margin-top:0.25rem; color:#bbb; font-size:0.9rem}
    #legend .swatch{ width:10px; height:10px; border-radius:2px; display:inline-block; margin-right:6px; background:var(--accent) }
    #legend .swatch.spark{ background:#6fa8dc }
    #avgRow{ display:flex; gap:0.5rem; align-items:center; justify-content:flex-start; margin:.25rem 0 .5rem; flex-wrap:wrap }
    #avg{ font-weight:700; font-variant-numeric: tabular-nums; }
    #controlsRow{ display:flex; flex-wrap:wrap; gap:0.35rem; justify-content:center; margin-top:0.5rem }
    .hint{ color:var(--muted); font-size:0.9rem; margin-top:0.5rem }
    /* Weak numbers table */
    table{ width:100%; border-collapse:collapse; font-size:0.95rem; }
    thead th{ text-align:left; color:#ddd; font-weight:600; border-bottom:1px solid #2a2a2a; padding:0.4rem 0.25rem }
    tbody td{ padding:0.35rem 0.25rem; border-bottom:1px dashed #222; color:#eee; }
    tbody tr:hover{ background:#161616 }
    .num{ font-variant-numeric: tabular-nums; text-align:right }
    .small-controls{ display:flex; gap:0.5rem; align-items:center; justify-content:space-between; flex-wrap:wrap; margin:0.35rem 0 0.5rem }
    .right{ justify-content:flex-end }
  </style>
</head>
<body>
  <h1>Italian Number Trainer</h1>

  <div id="number">—</div>
  <input id="userInput" type="text" placeholder="Scrivi il numero..." style="display:none;" aria-label="Inserisci il numero in cifre">
  <div id="timer" aria-live="polite">0.000 s</div>
  <div id="translation" style="visibility: hidden;">—</div>

  <div id="controlsRow">
    <button onclick="startTrainer()">Start</button>
    <button class="range-btn" id="btn100"   onclick="setMax(100)">Fino a 100</button>
    <button class="range-btn" id="btn1000"  onclick="setMax(1000)">Fino a 1.000</button>
    <button class="range-btn" id="btn10000" onclick="setMax(10000)">Fino a 10.000</button>
    <button class="range-btn" id="btn100000" onclick="setMax(100000)">Fino a 100.000</button>
    <button id="reverseBtn" onclick="toggleReverse()">↔ Inverti</button>
    <button onclick="clearStats()">Clear stats</button>
    <button onclick="downloadTrialsCSV()">Download Trials CSV</button>
    <button onclick="downloadAggregateCSV()">Download Per‑Number CSV</button>
<div style="margin:1rem 0">
  <button id="nextBtn" style="font-size:1.2rem; padding:0.75rem 1.25rem; width:90%">
    ▶ Next / Reveal
  </button>
</div>


  </div>

  <div id="metaRow">
    <div class="pill">Press <b>Space</b> to reveal / next</div>
    <div class="pill">Press <b>Enter</b> for next (after reveal)</div>
  </div>

  <div id="statsWrap">
    <div class="card" aria-live="polite" id="avgRow">
      <span class="subtle">Average time:</span> <span id="avg">0.000 s</span>
      <span class="subtle" style="margin-left:.5rem">Trials: <span id="count">0</span></span>
      <span class="subtle" style="margin-left:.5rem">Best: <span id="best">—</span></span>
      <span class="subtle" style="margin-left:.5rem">P95: <span id="p95">—</span></span>
    </div>

    <div class="stats-grid">
      <div class="card">
        <h2>Running histogram</h2>
        <p class="subtle">Thin bars show count per time bin. Bins adapt to your current range.</p>
        <canvas id="hist" width="800" height="200"></canvas>
        <div id="legend"><span><span class="swatch"></span>Histogram</span></div>
      </div>

      <div class="card">
        <h2>Per-trial spark bars</h2>
        <p class="subtle">Each thin bar is one trial’s time.</p>
        <canvas id="spark" width="800" height="110"></canvas>
      </div>
    </div>

    <div class="card" style="margin-top:.75rem">
      <div class="small-controls">
        <h2 style="margin:0">Weak Numbers</h2>
        <div>
          <label for="metricSelect" class="subtle">Rank by:</label>
          <select id="metricSelect">
            <option value="avgTime">Average time (desc)</option>
            <option value="errorRate">Error rate (desc)</option>
            <option value="count">Seen count (desc)</option>
          </select>
        </div>
      </div>
      <p class="subtle" style="margin-top:0">Tracks each number’s average response time and error rate. Top 10 shown.</p>
      <canvas id="weakChart" width="900" height="180"></canvas>
      <div class="small-controls right">
        <span class="subtle">Showing top <span id="topN">10</span></span>
      </div>
      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th style="width:18%">Number</th>
              <th class="num" style="width:12%">Seen</th>
              <th class="num" style="width:18%">Avg time (s)</th>
              <th class="num" style="width:18%">Median (s)</th>
              <th class="num" style="width:18%">Wrong %</th>
              <th class="num" style="width:16%">Last time (s)</th>
            </tr>
          </thead>
          <tbody id="weakTbody"></tbody>
        </table>
      </div>
    </div>

    <p class="hint">Tip: toggle <b>↔ Inverti</b> to switch between Italian→digits and digits→Italian. In reverse mode, answers are checked for correctness.</p>
  </div>

  <script>
    // ===== Trainer State =====
    let reverseMode = false;
    let currentNumber = null;
    let maxRange = 100;
    let startTime = null;
    let running = false;
    let translationShown = false;

    const numberEl = document.getElementById("number");
    const timerEl = document.getElementById("timer");
    const translationEl = document.getElementById("translation");
    const userInput = document.getElementById("userInput");

    function toggleReverse() {
      reverseMode = !reverseMode;
      document.getElementById("reverseBtn").classList.toggle("active", reverseMode);
      userInput.style.display = reverseMode ? "inline-block" : "none";
      if (reverseMode) {
        userInput.value = "";
        userInput.focus();
      }
    }

    function setMax(val) {
      maxRange = val;
      document.querySelectorAll('.range-btn').forEach(btn => btn.classList.remove('active'));
      const activeBtn = document.getElementById('btn' + val);
      if (activeBtn) {
        activeBtn.classList.add('active');
      }
    }

    function numberToItalian(n) {
      if (n === 100000) return "centomila";

      const ones = ["", "uno", "due", "tre", "quattro", "cinque", "sei", "sette", "otto", "nove"];
      const teens = ["dieci", "undici", "dodici", "tredici", "quattordici", "quindici", "sedici", "diciassette", "diciotto", "diciannove"];
      const tens = ["", "", "venti", "trenta", "quaranta", "cinquanta", "sessanta", "settanta", "ottanta", "novanta"];
      const hundreds = ["", "cento", "duecento", "trecento", "quattrocento", "cinquecento", "seicento", "settecento", "ottocento", "novecento"];

      function getBelowThousand(num) {
        if (num < 10) return ones[num];
        if (num < 20) return teens[num - 10];
        if (num < 100) {
          let ten = Math.floor(num / 10);
          let unit = num % 10;
          let t = tens[ten];
          if (unit === 1 || unit === 8) t = t.slice(0, -1);
          return t + ones[unit];
        }
        if (num < 1000) {
          let cent = Math.floor(num / 100);
          let rest = num % 100;
          let c = hundreds[cent];
          if (rest >= 80 && rest < 90 && c.endsWith("o")) c = c.slice(0, -1);
          return c + getBelowThousand(rest);
        }
        return "";
      }

      if (n < 1000) return getBelowThousand(n);

      const thousands = Math.floor(n / 1000);
      const rest = n % 1000;
      let prefix = "";

      if (thousands === 1) {
        prefix = "mille";
      } else {
        prefix = getBelowThousand(thousands) + "mila";
      }

      return prefix + getBelowThousand(rest);
    }

    function getRandomNumber() {
      return Math.floor(Math.random() * maxRange) + 1;
    }

    function showNewNumber() {
      currentNumber = getRandomNumber();
      translationShown = false;
      translationEl.style.visibility = "hidden";
      translationEl.style.color = "white";
      translationEl.textContent = reverseMode ? currentNumber.toLocaleString("it-IT") : numberToItalian(currentNumber);
      numberEl.textContent = reverseMode ? numberToItalian(currentNumber) : currentNumber.toLocaleString("it-IT");
      if (reverseMode) {
        userInput.style.display = "inline-block";
        userInput.value = "";
        userInput.focus();
      } else {
        userInput.style.display = "none";
      }
      startTime = performance.now();
      running = true;
      timerEl.textContent = "0.000 s";
    }

    function startTrainer() {
      showNewNumber();
    }

    document.addEventListener("keydown", (e) => {
      if (!running) return;
      if (e.code === "Space") {
        e.preventDefault();
        if (!translationShown) {
          const elapsed = (performance.now() - startTime) / 1000;
          timerEl.textContent = `${elapsed.toFixed(3)} s`;

          let correct = true;
          if (reverseMode) {
            const guess = userInput.value.replace(/[.,\\s]/g, '');
            const actual = currentNumber.toString();
            correct = (guess === actual);
            if (correct) {
              translationEl.style.color = 'lightgreen';
            } else {
              translationEl.style.color = 'salmon';
            }
          }
          recordTrial(elapsed, correct, currentNumber);

          translationEl.style.visibility = "visible";
          translationShown = true;
        } else {
          showNewNumber();
        }
      } else if (e.code === "Enter" && translationShown) {
        showNewNumber();
      }
    });

    // ===== Stats & Visualization =====
    const times = []; // seconds (legacy)
    const trials = []; // {number, time, correct, ts}

    const histCanvas = document.getElementById('hist');
    const sparkCanvas = document.getElementById('spark');
    const weakCanvas = document.getElementById('weakChart');
    const histCtx = histCanvas.getContext('2d');
    const sparkCtx = sparkCanvas.getContext('2d');
    const weakCtx = weakCanvas.getContext('2d');

    const avgEl = document.getElementById('avg');
    const countEl = document.getElementById('count');
    const bestEl = document.getElementById('best');
    const p95El = document.getElementById('p95');
    const metricSelect = document.getElementById('metricSelect');
    const weakTbody = document.getElementById('weakTbody');
    const topNEl = document.getElementById('topN');

    metricSelect.addEventListener('change', () => { updateWeak(); drawWeakChart(); });

    function recordTrial(sec, correct, number){
      if (!isFinite(sec) || sec <= 0) return;
      times.push(sec);
      trials.push({ number, time: sec, correct: !!correct, ts: Date.now() });
      updateStats();
      drawSpark();
      drawHistogram();
      updateWeak();
      drawWeakChart();
    }

    function clearStats(){
      times.length = 0;
      trials.length = 0;
      updateStats();
      clearCanvas(histCtx, histCanvas);
      clearCanvas(sparkCtx, sparkCanvas);
      clearCanvas(weakCtx, weakCanvas);
      weakTbody.innerHTML = "";
    }

    function downloadTrialsCSV(){
      if (trials.length === 0){
        alert("No trials yet.");
        return;
      }
      const rows = ["trial,number,time_s,correct,timestamp"];
      trials.forEach((t,i)=> rows.push(`${i+1},${t.number},${t.time.toFixed(3)},${t.correct ? 1 : 0},${new Date(t.ts).toISOString()}`));
      downloadBlob(rows.join("\\n"), "number_trainer_trials.csv");
    }

    function downloadAggregateCSV(){
      const agg = computeAggregate();
      if (agg.length === 0){
        alert("No data yet.");
        return;
      }
      const rows = ["number,seen,avg_time_s,median_s,wrong_pct,last_time_s"];
      agg.forEach(a=> rows.push([a.number, a.count, a.avg.toFixed(3), a.median.toFixed(3), (a.wrongRate*100).toFixed(1), a.lastTime.toFixed(3)].join(",")));
      downloadBlob(rows.join("\\n"), "number_trainer_per_number.csv");
    }

    function downloadBlob(text, filename){
      const blob = new Blob([text], {type:"text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateStats(){
      const n = times.length;
      countEl.textContent = n;
      if (n === 0){
        avgEl.textContent = "0.000 s";
        bestEl.textContent = '—';
        p95El.textContent = '—';
        return;
      }
      const sum = times.reduce((a,b)=>a+b,0);
      const avg = sum / n;
      avgEl.textContent = avg.toFixed(3) + " s";
      const best = Math.min(...times);
      bestEl.textContent = best.toFixed(3) + " s";
      const sorted = [...times].sort((a,b)=>a-b);
      const idx = Math.max(0, Math.min(n-1, Math.ceil(0.95*n)-1));
      const p95 = sorted[idx];
      p95El.textContent = p95.toFixed(3) + " s";
    }

    function clearCanvas(ctx, cv){
      ctx.clearRect(0,0,cv.width,cv.height);
    }

    function drawSpark(){
      const w = sparkCanvas.width;
      const h = sparkCanvas.height;
      clearCanvas(sparkCtx, sparkCanvas);
      if (times.length === 0) return;
      const maxT = Math.max(...times);
      const pad = 8;
      const innerH = h - pad*2;
      const innerW = w - pad*2;
      const barW = Math.max(1, innerW / Math.max(50, times.length)); // thin bars
      sparkCtx.save();
      sparkCtx.translate(pad, pad);
      // axis baseline
      sparkCtx.globalAlpha = 0.35;
      sparkCtx.fillStyle = "#ffffff";
      sparkCtx.fillRect(0, innerH, innerW, 1);
      sparkCtx.globalAlpha = 1;
      // bars
      sparkCtx.fillStyle = "#6fa8dc";
      for (let i=0;i<times.length;i++){
        const x = i * barW;
        const val = times[i];
        const barH = Math.max(1, (val / (maxT||1)) * innerH);
        sparkCtx.fillRect(Math.floor(x), Math.floor(innerH - barH), Math.ceil(barW*0.8), Math.ceil(barH));
      }
      sparkCtx.restore();
    }

    function drawHistogram(){
      const w = histCanvas.width;
      const h = histCanvas.height;
      clearCanvas(histCtx, histCanvas);
      if (times.length === 0) return;
      // Determine bins: 20 bins from 0 to max (rounded up to nice step)
      let maxT = Math.max(...times);
      // snap max to a nice round ceiling (like 0.5s steps, 1s, 2s, 5s)
      const niceStep = niceNumber(maxT/5, true);
      const niceMax = Math.ceil(maxT / niceStep) * niceStep;
      const binsCount = 20;
      const binSize = niceMax / binsCount;
      const bins = new Array(binsCount).fill(0);
      for (const t of times){
        let idx = Math.floor(t / binSize);
        if (idx >= binsCount) idx = binsCount - 1;
        bins[idx]++;
      }
      const maxBin = Math.max(...bins);
      const pad = 12;
      const innerW = w - pad*2;
      const innerH = h - pad*2;
      const barW = innerW / binsCount;

      histCtx.save();
      histCtx.translate(pad, pad);
      // baseline
      histCtx.globalAlpha = 0.35;
      histCtx.fillStyle = "#ffffff";
      histCtx.fillRect(0, innerH, innerW, 1);
      histCtx.globalAlpha = 1;

      // bars
      histCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || "#4bc0c0";
      for (let i=0;i<binsCount;i++){
        const count = bins[i];
        const x = i * barW;
        const barH = Math.max(1, (count / (maxBin||1)) * innerH);
        histCtx.fillRect(Math.floor(x + barW*0.15), Math.floor(innerH - barH), Math.ceil(barW*0.7), Math.ceil(barH));
      }

      // simple x-axis ticks (0, mid, max)
      histCtx.globalAlpha = 0.8;
      histCtx.fillStyle = "#bbb";
      histCtx.font = "12px system-ui, sans-serif";
      histCtx.textAlign = "left";
      histCtx.fillText("0s", 0, innerH + 14);
      histCtx.textAlign = "center";
      histCtx.fillText((niceMax/2).toFixed(2) + "s", innerW/2, innerH + 14);
      histCtx.textAlign = "right";
      histCtx.fillText(niceMax.toFixed(2) + "s", innerW, innerH + 14);
      histCtx.restore();
    }

    // ===== Weak numbers aggregation & UI =====
    function computeAggregate(){
      if (trials.length === 0) return [];
      const map = new Map();
      for (const t of trials){
        const key = t.number;
        if (!map.has(key)){
          map.set(key, { number:key, count:0, sum:0, times:[], wrong:0, lastTime:0 });
        }
        const obj = map.get(key);
        obj.count += 1;
        obj.sum += t.time;
        obj.times.push(t.time);
        if (!t.correct) obj.wrong += 1;
        obj.lastTime = t.time; // last seen time (by chronological push)
      }
      const agg = [];
      for (const obj of map.values()){
        const timesSorted = obj.times.slice().sort((a,b)=>a-b);
        const n = timesSorted.length;
        const median = n%2 ? timesSorted[(n-1)/2] : (timesSorted[n/2-1] + timesSorted[n/2]) / 2;
        agg.push({
          number: obj.number,
          count: obj.count,
          avg: obj.sum / obj.count,
          median,
          wrongRate: obj.wrong / obj.count,
          lastTime: obj.lastTime
        });
      }
      return agg;
    }

    function updateWeak(){
      const agg = computeAggregate();
      weakTbody.innerHTML = "";
      if (agg.length === 0) return;

      const metric = metricSelect.value;
      let sorted = agg.slice();
      if (metric === "avgTime"){
        sorted.sort((a,b)=> b.avg - a.avg);
      } else if (metric === "errorRate"){
        sorted.sort((a,b)=> b.wrongRate - a.wrongRate);
      } else if (metric === "count"){
        sorted.sort((a,b)=> b.count - a.count);
      }

      const topN = Math.min(10, sorted.length);
      topNEl.textContent = topN.toString();

      for (let i=0; i<topN; i++){
        const a = sorted[i];
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${a.number.toLocaleString("it-IT")}</td>
          <td class="num">${a.count}</td>
          <td class="num">${a.avg.toFixed(3)}</td>
          <td class="num">${a.median.toFixed(3)}</td>
          <td class="num">${(a.wrongRate*100).toFixed(1)}</td>
          <td class="num">${a.lastTime.toFixed(3)}</td>
        `;
        weakTbody.appendChild(tr);
      }
    }

    function drawWeakChart(){
      const w = weakCanvas.width;
      const h = weakCanvas.height;
      clearCanvas(weakCtx, weakCanvas);
      const agg = computeAggregate();
      if (agg.length === 0) return;

      const metric = metricSelect.value;
      let sorted = agg.slice();
      let values = [];
      if (metric === "avgTime"){
        sorted.sort((a,b)=> b.avg - a.avg);
        values = sorted.slice(0,10).map(a=>({label: a.number, val:a.avg}));
      } else if (metric === "errorRate"){
        sorted.sort((a,b)=> b.wrongRate - a.wrongRate);
        values = sorted.slice(0,10).map(a=>({label: a.number, val:a.wrongRate*100})); // as percent
      } else {
        sorted.sort((a,b)=> b.count - a.count);
        values = sorted.slice(0,10).map(a=>({label: a.number, val:a.count}));
      }

      const pad = 8;
      const innerW = w - pad*2;
      const innerH = h - pad*2;
      weakCtx.save();
      weakCtx.translate(pad, pad);

      const maxVal = Math.max(...values.map(v=>v.val)) || 1;
      const barW = innerW / values.length;

      // baseline
      weakCtx.globalAlpha = 0.35;
      weakCtx.fillStyle = "#ffffff";
      weakCtx.fillRect(0, innerH, innerW, 1);
      weakCtx.globalAlpha = 1;

      // bars
      weakCtx.fillStyle = "#9f7aea"; // purple-ish for contrast
      for (let i=0; i<values.length; i++){
        const v = values[i];
        const barH = Math.max(1, (v.val / maxVal) * innerH);
        weakCtx.fillRect(Math.floor(i*barW + barW*0.15), Math.floor(innerH - barH), Math.ceil(barW*0.7), Math.ceil(barH));
      }

      // x labels (numbers)
      weakCtx.fillStyle = "#bbb";
      weakCtx.font = "11px system-ui, sans-serif";
      weakCtx.textAlign = "center";
      for (let i=0; i<values.length; i++){
        const x = i*barW + barW/2;
        weakCtx.fillText(String(values[i].label), x, innerH + 14);
      }

      // value label at top right
      weakCtx.textAlign = "right";
      weakCtx.fillText(metric === "avgTime" ? "Avg time (s)" : (metric === "errorRate" ? "Wrong %" : "Seen count"), innerW, 10);
      weakCtx.restore();
    }

    // Nice number helper (for histogram)
    function niceNumber(range, round){
      const exponent = Math.floor(Math.log10(range));
      const fraction = range / Math.pow(10, exponent);
      let niceFraction;
      if (round){
        if (fraction < 1.5) niceFraction = 1;
        else if (fraction < 3) niceFraction = 2;
        else if (fraction < 7) niceFraction = 5;
        else niceFraction = 10;
      } else {
        if (fraction <= 1) niceFraction = 1;
        else if (fraction <= 2) niceFraction = 2;
        else if (fraction <= 5) niceFraction = 5;
        else niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    }

    // HiDPI scaling for crisp lines
    function fixCanvasResolution(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      if (canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr)){
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function resizeAll(){
      fixCanvasResolution(histCanvas);
      fixCanvasResolution(sparkCanvas);
      fixCanvasResolution(weakCanvas);
      drawHistogram();
      drawSpark();
      drawWeakChart();
    }
    window.addEventListener('resize', resizeAll);
    window.addEventListener('load', resizeAll);
  
// Mobile-friendly button for reveal/next
(function(){
  const btn = document.getElementById("nextBtn");
  if (!btn) return;
  btn.addEventListener("click", () => {
    if (!running) return;
    if (!translationShown) {
      const elapsed = (performance.now() - startTime) / 1000;
      timerEl.textContent = `${elapsed.toFixed(3)} s`;

      let correct = true;
      if (reverseMode) {
        const guess = userInput.value.replace(/[.,\s]/g, '');
        const actual = currentNumber.toString();
        correct = (guess === actual);
        translationEl.style.color = correct ? 'lightgreen' : 'salmon';
      }
      recordTrial(elapsed, correct, currentNumber);

      translationEl.style.visibility = "visible";
      translationShown = true;
    } else {
      showNewNumber();
    }
  });
})();

</script>

  <!-- Service worker registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch(console.error);
      });
    }
  </script>
</body>
</html>
